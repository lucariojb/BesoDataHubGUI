import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:http/http.dart' as http;

class Exec {}

class Konnektor {
  String name;
  String? comment;
  final String exec;
  final String execPath;
  final List<Konfig> konfig;
  // final List<Job> jobs;

  Konnektor({
    required this.exec,
    required this.execPath,
    required this.name,
    this.comment = "",
    this.konfig = const [],
    // this.jobs = const [],
  });

  @override
  int get hashCode => Object.hash(name, Object.hashAll(konfig));
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Konnektor) return false;
    return name == other.name && listEquals(konfig, other.konfig);
  }

  @override
  String toString() {
    return 'Name: $name, Exec: $exec, Konfig: ${konfig.map((e) => e.toString())}';
  }

  Konnektor copy() {
    return Konnektor(
      name: name,
      exec: exec,
      konfig: konfig.map((e) => e.copy()).toList(),
      // jobs: jobs.map((e) => e.copy()).toList(),
    );
  }

  factory Konnektor.getNew({required String name, required String exec}) {
    return Konnektor(
      name: name,
      exec: exec,
      konfig: [Konfig.getDummy()],
    );
  }

  static Future<List<String>> loadKonnektorNames() async {
    return (await MySQL.runQueryAsMap("SELECT DISTINCT Konnektor FROM konfig"))
        .map((e) => e["Konnektor"].toString())
        .toList();
  }

  static Future<String> loadExec(String konnektorName) async {
    final result = await MySQL.runQueryAsMap(
        "SELECT DISTINCT Wert FROM konfig WHERE Konnektor = '$konnektorName' AND Typ = 'Exec' AND Schluessel = 'EXEC'");
    if (result.isNotEmpty) {
      return result.first["Wert"] ?? '';
    } else {
      return 'Not Found!';
    }
  }

  static Future<List<Konnektor>> loadFromMySQL() async {
    print("Loading Konnektoren from MySQL...");
    List<String> rawKonnektoren = await loadKonnektorNames();
    print("Loaded Konnektoren: $rawKonnektoren");

    List<Konnektor> konnektoren = [];
    for (String konnektor in rawKonnektoren) {
      String exec = await loadExec(konnektor);
      if (konnektor.isEmpty) {
        continue;
      }
      List<Konfig> konfig = await Konfig.loadForKonnektor(konnektor);
      // List<Job> jobs = await Job.loadJobsForKonnektor(konnektor);

      konnektoren.add(Konnektor(name: konnektor, exec: exec, konfig: konfig));
    }
    return konnektoren;
  }

  static Future<List<String>> loadExecs() async {
    return rootBundle
        .loadString(r'assets\DataHubKonfigStruktur.json')
        .then((data) {
      List<dynamic> jsonData = jsonDecode(data);
      return jsonData.map((e) => e["EXE"].toString()).toList();
    });
  }

  Map<String, dynamic> toMap() {
    return {
      "Konnektor": name,
      "Exec": exec,
      "Konfig": konfig.map((e) => e.toMap()).toList(),
      // "Jobs": jobs.map((e) => e.toMap()).toList(),
    };
  }

  Future<bool> saveKonnektor() async {
    List<Map<String, dynamic>> dataToSave = [];
    //Save Konfigs
    for (Konfig k in konfig) {
      dataToSave.add(k.toMap());
    }
    for (Map<String, dynamic> row in dataToSave) {
      row.addEntries(
          [MapEntry("Konnektor", name), const MapEntry("Typ", "Konfig")]);
    }
    //Save Exec
    dataToSave.add({
      "Konnektor": name,
      "Schluessel": "EXEC",
      "Wert": exec,
      "Typ": "Exec",
    });
    //Save Comment
    dataToSave.add({
      "Konnektor": name,
      "Schluessel": "Kommentar",
      "Wert": comment,
      "Typ": "Comment",
    });

    //Apply to MySQL
    for (Map<String, dynamic> row in dataToSave) {
      MySQL.insertIntoTable("konfig", row);
    }
    return true;
    // for (Map<String, dynamic> row in dataToSave) {
    //   // Check if the row already exists
    //   String query = "SELECT COUNT(*) as count FROM konfig WHERE "
    //       "Konnektor = '${row["Konnektor"]}' AND "
    //       "Schluessel = '${row["Schluessel"]}' AND "
    //       "Typ = '${row["Typ"]}'";
    //   MySQL.runQueryAsMap(query).then((result) async {
    //     if (result.isNotEmpty && result.first["count"] > 0) {
    //       // Row exists, update it
    //     } else {
    //       // Row does not exist, insert it
    //       print(await MySQL.insertIntoTable("konfig", row));
    //     }
    //   });
  }
}

// Future<void> loadKonnektorOptions(String exec, Stro) async {
//   rootBundle.loadString(r'assets\DataHubKonfigStruktur.json').then((data) {
//     List<Map<String, dynamic>> jsonData = jsonDecode(data);
//     Map<String, dynamic> konfigData = jsonData.firstWhere(
//         (element) => element["EXE"].toString() == exec,
//         orElse: () => {});
//     if (konfigData.isNotEmpty) {
//       konfig = konfigData["Konfig"].toString().split(',');
//     }
//   });
// }

class Konfig {
  final String name;
  final String comment;
  String value;
  final List<String> optionen;
  final bool isRequired;

  Konfig({
    required this.name,
    required this.comment,
    required this.value,
    required this.optionen,
    this.isRequired = false,
  });

  @override
  int get hashCode => Object.hash(name, value, comment);
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Konfig) return false;
    return name == other.name &&
        value == other.value &&
        comment == other.comment;
  }

  @override
  String toString() {
    return 'Name: $name, Comment: $comment, Value: $value, Optionen: ${optionen.join(', ')}, isRequired: $isRequired';
  }

  Konfig copy() {
    return Konfig(
      name: name,
      comment: comment,
      value: value,
      optionen: optionen.map((e) => e).toList(),
      isRequired: isRequired,
    );
  }

  static Konfig getDummy() {
    return Konfig(
      name: 'Dummy Konfig',
      comment: 'This is a dummy comment',
      value: 'Dummy Value',
      optionen: ['Option 1', 'Option 2'],
      isRequired: true,
    );
  }

  factory Konfig.fromMap(Map<String, dynamic> data) {
    return Konfig(
      name: data["Schluessel"],
      comment: data["Kommentar"],
      value: data["Wert"],
      optionen: data["Optionen"].toString().split(','),
    );
  }

  factory Konfig.fromJSON(String data) {
    Map<String, dynamic> jsonData = jsonDecode(data);
    return Konfig.fromMap(jsonData);
  }

  static loadForKonnektor(String konnektor) {
    return MySQL.runQueryAsMap(
            "SELECT Schluessel, Wert, Kommentar, Optionen FROM konfig WHERE Konnektor = '$konnektor' AND Typ = 'Konfig' AND (Jobname IS NULL OR Jobname = '') ")
        .then((data) => data.map((e) => Konfig.fromMap(e)).toList());
  }

  static loadForJob(String konnektor, String job) {
    return MySQL.runQueryAsMap(
            "SELECT Schluessel, Wert, Kommentar, Optionen, Wert FROM konfig WHERE Konnektor = '$konnektor' AND Typ = 'Konfig' AND Jobname = '$job' ")
        .then((data) => data.map((e) => Konfig.fromMap(e)).toList());
  }

  Map<String, dynamic> toMap() {
    return {
      "Schluessel": name,
      // "Kommentar": comment,
      "Wert": value,
      // "Optionen": optionen.join(','),
    };
  }
}

class Job {
  final String name;
  final List<Konfig> konfig;

  const Job({
    required this.name,
    required this.konfig,
  });

  @override
  String toString() {
    return 'Name: $name, Konfig: ${konfig.map((e) => e.toString())}';
  }

  Job copy() {
    return Job(
      name: name,
      konfig: konfig.map((e) => e.copy()).toList(),
    );
  }

  static Job getDummy([int index = 1]) {
    return Job(
      name: 'Dummy Job $index',
      konfig: [Konfig.getDummy()],
    );
  }

  static Future<List<String>> loadJobNamesForKonnektor(String konnektor) async {
    return MySQL.runQueryAsMap(
            "SELECT DISTINCT Jobname FROM konfig WHERE Konnektor = '$konnektor' AND Typ = 'Job'")
        .then((data) => data.map((e) => e["Jobname"].toString()).toList());
  }

  static Future<List<Job>> loadJobsForKonnektor(String konnektor) async {
    List<String> rawJobs = await loadJobNamesForKonnektor(konnektor);
    List<Job> jobs = [];
    for (String job in rawJobs) {
      List<Konfig> konfig = await Konfig.loadForJob(konnektor, job);
      jobs.add(Job(name: job, konfig: konfig));
    }
    return jobs;
  }

  static Future<List<Job>> loadJobsForKonnektorAndName(
      String konnektor, String job) async {
    List<Konfig> konfig = await Konfig.loadForJob(konnektor, job);
    return [Job(name: job, konfig: konfig)];
  }
}

class MySQL {
  static const String url = "http://127.0.0.1:5000";

  static Future<String> runQuery(String query) async {
    final response = await http.post(Uri.parse('$url/runquery'),
        headers: <String, String>{'Content-Type': 'application/json'},
        body: '{"query": "$query"}');

    if (response.statusCode == 200) {
      return response.body;
    } else {
      throw Exception(
          'Failed to Load Data from MySQL. Status: ${response.statusCode}\nBody: ${response.body}');
    }
  }

  static Future<List<Map<String, dynamic>>> runQueryAsMap(String query) async {
    String data = await runQuery(query);
    return jsonDecode(data).cast<Map<String, dynamic>>();
  }

  static Future<bool> insertIntoTable(
      String table, Map<String, dynamic> data) async {
    final response = await http.post(Uri.parse('$url/insert'),
        headers: <String, String>{'Content-Type': 'application/json'},
        body: jsonEncode({
          "table": table,
          "data": data,
        }));

    if (response.statusCode == 201) {
      return true;
    } else {
      // throw Exception(
      //     'Failed to insert data into MySQL. Status: ${response.statusCode}\nBody: ${response.body}');
      return false;
    }
  }
}
